"""Attachment download endpoints for app package.

Provides secure, validated endpoints for downloading message attachments.
"""
from __future__ import annotations

import os
from typing import Optional

from fastapi import APIRouter, HTTPException, Request, Depends
from fastapi.responses import FileResponse
from sqlalchemy.orm import Session

from app.database import get_db
from app import models
from app.dependencies import can_access_ticket, require_agent_or_admin
from app.auth import get_current_user

router = APIRouter(tags=["Attachments"])

UPLOAD_MESSAGES_DIR = os.path.abspath(os.path.join(os.getcwd(), "uploads", "messages"))


@router.get("/api/attachments/messages/{path:path}")
async def download_message_attachment(path: str, request: Request, db: Session = Depends(get_db), current_user: models.UserModel = Depends(get_current_user)):
    # Decode any percent-encoding (we expect the path to be quoted when generated by the API)
    from urllib.parse import unquote

    decoded = unquote(path)

    # Reject obvious traversal
    if ".." in decoded:
        raise HTTPException(status_code=400, detail="Invalid file path")

    # Normalize incoming path: strip leading uploads/messages/ if present
    prefix = "uploads/messages/"
    if decoded.startswith(prefix):
        rel = decoded[len(prefix):]
    elif decoded.startswith("messages/"):
        rel = decoded[len("messages/"):]
    else:
        rel = decoded

    filepath = os.path.abspath(os.path.join(UPLOAD_MESSAGES_DIR, rel))
    if not filepath.startswith(UPLOAD_MESSAGES_DIR):
        raise HTTPException(status_code=400, detail="Invalid file path")

    if not os.path.isfile(filepath):
        raise HTTPException(status_code=404, detail="File not found")

    # Authorization: ensure the message exists and the current_user can access the ticket
    # Expect rel format: "{message_id}/{filename}"
    parts = rel.split("/", 1)
    if len(parts) < 2:
        raise HTTPException(status_code=404, detail="Message not found")

    message_id = parts[0]
    msg = db.query(models.MessageModel).filter(models.MessageModel.id == message_id).first()
    if not msg:
        raise HTTPException(status_code=404, detail="Message not found")

    # Ensure the attachment exists in the message's attachments list
    try:
        attachments = [] if not msg.attachments else __import__("json").loads(msg.attachments)
    except Exception:
        attachments = []

    # Check exact path match or filename suffix match (support dict items with 'path')
    def _item_path(item):
        if isinstance(item, str):
            return item
        if isinstance(item, dict):
            return item.get("path", "")
        return ""

    if not any(_item_path(a) == rel for a in attachments):
        # If the exact relative path is not present, check for filename-only match as fallback
        filename = os.path.basename(rel)
        if not any(_item_path(a).endswith(filename) for a in attachments):
            raise HTTPException(status_code=404, detail="Attachment not found")

    # Check ticket access
    ticket = db.query(models.TicketModel).filter(models.TicketModel.id == msg.ticket_id).first()
    if not can_access_ticket(ticket, current_user):
        raise HTTPException(status_code=403, detail="Access to this attachment is forbidden")

    filename = os.path.basename(filepath)
    original_name = "_".join(filename.split("_")[1:]) if "_" in filename else filename

    return FileResponse(path=filepath, filename=original_name, media_type="application/octet-stream", headers={"Content-Disposition": f'attachment; filename="{original_name}"'})


# ---------------------------------------------------------------------------
# Tickets attachments
# ---------------------------------------------------------------------------
UPLOAD_TICKETS_DIR = os.path.abspath(os.path.join(os.getcwd(), "uploads", "tickets"))


@router.get("/api/attachments/tickets/{path:path}")
async def download_ticket_attachment(path: str, request: Request, current_user: models.UserModel = Depends(require_agent_or_admin)):
    """Download an attachment stored under uploads/tickets.

    Accepts either the bare unique filename (e.g. "<uuid>_file.txt") or a
    quoted full path (e.g. "uploads/tickets/<uuid>_file.txt").
    """
    from urllib.parse import unquote

    decoded = unquote(path)

    if ".." in decoded:
        raise HTTPException(status_code=400, detail="Invalid file path")

    # Normalize incoming path: strip leading uploads/tickets/ or tickets/ if present
    prefix = "uploads/tickets/"
    if decoded.startswith(prefix):
        rel = decoded[len(prefix):]
    elif decoded.startswith("tickets/"):
        rel = decoded[len("tickets/"):]
    else:
        rel = decoded

    filepath = os.path.abspath(os.path.join(UPLOAD_TICKETS_DIR, rel))
    if not filepath.startswith(UPLOAD_TICKETS_DIR):
        raise HTTPException(status_code=400, detail="Invalid file path")

    if not os.path.isfile(filepath):
        raise HTTPException(status_code=404, detail="File not found")

    filename = os.path.basename(filepath)
    original_name = "_".join(filename.split("_")[1:]) if "_" in filename else filename

    return FileResponse(path=filepath, filename=original_name, media_type="application/octet-stream", headers={"Content-Disposition": f'attachment; filename="{original_name}"'})
